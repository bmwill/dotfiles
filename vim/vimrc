" =========================================================
" vimrc
" Configuration file for Vim
"
" For more examples look at $VIMRUNTIME/vimrc_example.vim
" =========================================================

" -------------------------------------
"         General Configuration
" -------------------------------------

" Use Vim settings, rather then Vi settings
" This must be first, because it changes other options as a side effect
set nocompatible

" Load plugins if Vundle exists
if !empty(glob("$HOME/.vim/bundle/Vundle.vim"))
  source $HOME/.vim/plugins.vim
endif

syntax on                 " Turns syntax on
set history=1000          " Increase :cmdline history
set showcmd               " Display incomplete commands
set showmode              " Display current mode
set autoread              " read file when it is modified outside of vim
set autowrite             " write file when running some buffer motion commands
set number                " Turns on line numbering
set ruler                 " Status line shows cursor position
set cursorline            " Highlight the line containing the cursor
set mouse=a               " Enable the mouse in Terminal
set wildmenu              " Allow Tab completion of commands
set wildmode=list:longest " complete till longest common string
set wildignore+=*.o       " ignore compiled object files
set scrolloff=3           " Scroll 3 lines prior to horizontal border
"set clipboard=unnamed    " Use the OS clipboard by default
let mapleader=","         " Change <Leader>, default is '\'
"set cpoptions+=J         " use two spaces to denote a sentence

" Time out on key codes but not mappings.
" Basically this makes terminal Vim work sanely.
"set notimeout
"set ttimeout
"set ttimeoutlen=10

" -------------------------------------
"               Movement
" -------------------------------------

" Allow backspacing in insert mode
set backspace=indent,eol,start

" Change j and k to move through wrapped lines
nnoremap j gj
nnoremap k gk

" Jump to tag in a new split
nnoremap <c-\> <c-w>v<c-]>

" -------------------------------------
"               Colors
" -------------------------------------

" Set default colorscheme to desert
colorscheme desert
" If the 'molokai' colorscheme exists, use it instead
" as well as making it look closer to the gui colors
let g:molokai_original = 1
let g:rehash256 = 1
silent! colorscheme molokai

" disable Background Color Erase (BCE) so that color schemes
" render properly when inside 256-color tmux and GNU screen.
if &term =~ '256color'
  set t_ut=
endif

" Highlight VCS conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" -----------
"   Backups
" -----------

set undodir=~/.vim/tmp/undo//     " undo files
set backupdir=~/.vim/tmp/backup// " backups
set directory=~/.vim/tmp/swap//   " swap files
set viminfo+=n~/.vim/.viminfo     " viminfo location

" Make those folders automatically if they don't already exist.
if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
endif
if !isdirectory(expand(&backupdir))
    call mkdir(expand(&backupdir), "p")
endif
if !isdirectory(expand(&directory))
    call mkdir(expand(&directory), "p")
endif

" ------------
"   Spelling
" ------------

nnoremap <leader>sp :setlocal spell!<CR>
nnoremap <leader>sP :mkspell! ~/.vim/spell/dictionary.utf-8.add<CR>
set spelllang=en_us
set spellfile=~/.vim/spell/dictionary.utf-8.add

" -------------------------------------
"               Search
" -------------------------------------

set incsearch       " Search while typing
set hlsearch        " Highlight matching searches
set ignorecase      " ignore case while searching
set smartcase       " ignore case only when all lowercase

" Clear Search highlighting when hitting 'return'
" This unsets the 'last search pattern' register
nnoremap <CR> :noh<CR><CR>

" -------------------------------------
"             Indentation
" -------------------------------------

set autoindent      " Copy indentation from previous line
set expandtab       " Expands tabs into spaces
set tabstop=2       " Changes the width of the <TAB> character
set shiftwidth=2    " Affects how automatic indentation works (>>,<<,==)
set softtabstop=2   " Affects what happens when you press <TAB> or <BS>

" Enable file type detection
" Use the default filetype settings and
" Load indent files, to automatically do language-dependent indenting
filetype plugin indent on

" Show 'invisible' whitespace characters
set listchars=tab:▸-,trail:·,eol:¬,nbsp:_
"set list
" Toggle [i]nvisible characters
" nnoremap <leader>i :set list!<cr>

" -------------------------------------
"               Folding
" -------------------------------------

set foldmethod=indent   " Fold based on indent level
set foldnestmax=3       " Deepest fold is 3 levels
set nofoldenable        " Don't fold by Default

" Space to toggle folds
nnoremap <Space> za
vnoremap <Space> za

" Make zO recursively open whatever fold we're in, even if it's partially open.
nnoremap zO zczO

" -------------------------------------
"             Status Line
" -------------------------------------

set laststatus=2                  " Always displays the status line
set statusline=%t\                " Tail of the filename
set statusline+=%y                " Filetype
set statusline+=%{FileFormat()}   " File Encoding/Format
set statusline+=%r                " Read only flag
set statusline+=%m                " Modified flag
set statusline+=%=                " left/right separator
set statusline+=%c%V,             " Cursor column
set statusline+=%l/%L             " Cursor line/total lines
set statusline+=\ %P              " Percent through file

" Returns a string '[Encoding,Format]' for the statusline
" if the encoding isn't 'utf-8' or the format isn't 'unix'
function! FileFormat()
  let l:fmt = ''
  if &fenc != 'utf-8'
    let l:fmt = strlen(&fenc) ? &fenc : 'none'
  endif

  if &ff != 'unix'
    let l:fmt = strlen(l:fmt) ? l:fmt . ',' . &ff : &ff
  endif

  return strlen(l:fmt) ? '[' . l:fmt . ']' : ''
endfunction

" -------------------------------------
"               Splits
" -------------------------------------

set splitbelow  " Open new splits to the bottom
set splitright  " Open new splits to the right

"nnoremap <silent> <Right> :call IntelligentVerticalResize('right')<CR>
"nnoremap <silent> <Left> :call IntelligentVerticalResize('left')<CR>
"" Only map up and down arrows to resize if the GUI is running
"" This is because the CLI interprets mouse scrolling as arrow events
"if has('gui_running')
"  nnoremap <silent> <Up> :resize +1<CR>
"  nnoremap <silent> <Down> :resize -1<CR>
"end

" Be aware of whether you are right or left vertical split
" so you can use arrow keys more naturally to rezie windows
function! g:IntelligentVerticalResize(direction) abort
  let l:window_resize_count = 5
  let l:current_window_is_last_window = (winnr() == winnr('$'))

  if (a:direction ==# 'left')
    let [l:modifier_1, l:modifier_2] = ['+', '-']
  else
    let [l:modifier_1, l:modifier_2] = ['-', '+']
  endif

  let l:modifier = l:current_window_is_last_window ? l:modifier_1 : l:modifier_2
  let l:command = 'vertical resize ' . l:modifier . l:window_resize_count . '<CR>'
  execute l:command
endfunction

" -------------------------------------
"             Gui Options
" -------------------------------------
if has('gui_running')
  set guioptions=agim
endif

" allows cursor change in tmux mode
"if exists('$TMUX')
"  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
"  let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
"  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
"else
"  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
"  let &t_SR = "\<Esc>]50;CursorShape=2\x7"
"  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
"endif

" -----------------
"   Quick Editing
" -----------------

" edit vimrc and load vimrc bindings
nnoremap <leader>ev :vsp $MYVIMRC<CR>
nnoremap <leader>sv :source $MYVIMRC<CR>

" --------------------
"   General Mappings
" --------------------

nnoremap <leader>nr :setlocal relativenumber!

" Save with <C-s>
nnoremap <c-s> :update<CR>
inoremap <c-s> <Esc>:update<CR>
vnoremap <c-s> <Esc>:update<CR>gv

" Execute current line or current selection as Vim EX commands.
nnoremap <F2> :exe getline(".")<CR>
vnoremap <F2> :<C-w>exe join(getline("'<","'>"),'<Bar>')<CR>

" Remove all trailing whitespace by pressing F5 (maybe <leader>ww)
" uses mark 'z'
nnoremap <F5> mz:let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar><CR>`z
nnoremap <leader>ww mz:let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar><CR>`z

nnoremap <leader>m :call ToggleMouse()<CR>
function! ToggleMouse()
  " check if mouse is enabled
  if &mouse == 'a'
    " disable mouse
    set mouse=
  else
    " enable mouse everywhere
    set mouse=a
  endif
endfunc

" "Uppercase word" mapping
"
" This mapping allows you to press <c-u> in insert mode to convert the current
" word to uppercase.  It's handy when you're writing names of constants and
" don't want to use Capslock.
"
" To use it you type the name of the constant in lowercase.  While your
" cursor is at the end of the word, press <c-u> to uppercase it, and then
" continue happily on your way:
"
"                            cursor
"                            v
"     max_connections_allowed|
"     <c-u>
"     MAX_CONNECTIONS_ALLOWED|
"                            ^
"                            cursor
"
" It works by exiting out of insert mode using gUiw to uppercase inside the
" current word, then gi to enter insert mode at the end of the word.
inoremap <C-u> <esc>gUiwgi
" because completion breaks <C-u>
inoremap <C-g><C-u> <esc>gUiwgi

" Formatting
nnoremap Q gqip
vnoremap Q gq

" Wrap
" nnoremap <leader>W :set wrap!<cr>

noremap <leader>p "*p

" Yank to end of line
nnoremap Y y$

" highlight last inserted text
nnoremap gV `[v`]

" set virtualedit+=block

" Diffoff
nnoremap <leader>D :diffoff!<cr>

" What is the current syntax highlighting group?
map <F3> :echo
  \   "hi<" . synIDattr(synID(line("."),col("."),1),"name") . ">"
  \ . " trans<" . synIDattr(synID(line("."),col("."),0),"name") . ">"
  \ . " lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"
  \ . " FG:" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"fg#")
  \ . " BG:" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"bg#")<CR>

" Highlights characters that exceed the 80 char/line maximum
highlight OverLength ctermbg=52 guibg=#592929
"match OverLength /\%>80v.\+/
" Show trailing whitespace
"autocmd BufNewFile,BufRead *.c,*.cc,*.cpp,*.h match OverLength /\s\+$/
" Show Tabs
"autocmd BufNewFile,BufRead *.c,*.cc,*.cpp,*.h match OverLength /\t/

" -------------------------------------
"       Filetype Specific Settings
" -------------------------------------

autocmd BufNewFile,BufRead *.cc,*.cpp,*.h set syntax=cpp11
"autocmd BufNewFile,BufRead *.md set syntax=markdown
autocmd BufNewFile,BufRead *.c,*.cc,*.cpp,*.h match OverLength /\%>80v.\+/

" Git Dev Settings
autocmd! BufNewFile,BufReadPost $HOME/work/git/* call SetupGitEnv()
function! SetupGitEnv()
  "let l:path = expand('%:p')
  setlocal tabstop=8 shiftwidth=8 softtabstop=8 noexpandtab
endfunction

" Line Return
" Make sure Vim returns to the same line when you reopen a file.
augroup line_return
  autocmd!
  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \     execute 'normal! g`"zvzz' |
    \ endif
augroup END

" Standard In
augroup ft_stdin
  autocmd!
  " Treat buffers from stdin (e.g.: echo foo | vim -) as scratch.
  autocmd StdinReadPost * :set buftype=nofile
augroup END

" Function to enable syntax highlighting in code snippets
function! TextEnableCodeSnip(filetype,start,end,textSnipHl) abort
  let ft=toupper(a:filetype)
  let group='textGroup'.ft
  if exists('b:current_syntax')
    let s:current_syntax=b:current_syntax
    " Remove current syntax definition, as some syntax files (e.g. cpp.vim)
    " do nothing if b:current_syntax is defined.
    unlet b:current_syntax
  endif
  execute 'syntax include @'.group.' syntax/'.a:filetype.'.vim'
  try
    execute 'syntax include @'.group.' after/syntax/'.a:filetype.'.vim'
  catch
  endtry
  if exists('s:current_syntax')
    let b:current_syntax=s:current_syntax
  else
    unlet b:current_syntax
  endif
  let cmd='syntax region textSnip'.ft.'
    \ matchgroup='.a:textSnipHl.'
    \ start='.a:start.' end='.a:end.'
    \ contains=@'.group
  execute cmd
endfunction

autocmd! BufNewFile,BufReadPost $HOME/work/git/t/*.sh call TextEnableCodeSnip('sh', "/'$/", "/^'/", 'SpecialComment')
