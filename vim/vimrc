" =========================================================
" vimrc
" Configuration file for Vim
"
" For more examples look at $VIMRUNTIME/vimrc_example.vim
" =========================================================

" -------------------------------------
"         General Configuration
" -------------------------------------

" Use Vim settings, rather then Vi settings
" This must be first, because it changes other options as a side effect
set nocompatible

" Load plugins if Vundle exists
if !empty(glob("$HOME/.vim/bundle/Vundle.vim"))
  source $HOME/.vim/plugins.vim
endif

syntax on                 " Turns syntax on
set history=1000          " Increase :cmdline history
set showcmd               " Display incomplete commands
set showmode              " Display current mode
set number                " Turns on line numbering
set ruler                 " Status line shows cursor position
set cursorline            " Highlight the line containing the cursor
set mouse=a               " Enable the mouse in Terminal
set wildmenu              " Allow Tab completion of commands
set wildignore+=*.o       " ignore compiled object files
set scrolloff=3           " Scroll 3 lines prior to horizontal border
"set clipboard=unnamed    " Use the OS clipboard by default
let mapleader=","         " Change <Leader>, default is '\'
"set timeoutlen=2000       " 2 sec timeout for <Leader> commands


" -------------------------------------
"               Movement
" -------------------------------------

" Allow backspacing in insert mode
set backspace=indent,eol,start

" Change j and k to move through wrapped lines
nmap j gj
nmap k gk

" -------------------------------------
"               Colors
" -------------------------------------

" Set default colorscheme to desert
colorscheme desert
" If the 'molokai' colorscheme exists, use it instead
" as well as making it look closer to the gui colors
let g:molokai_original = 1
let g:rehash256 = 1
silent! colorscheme molokai

" disable Background Color Erase (BCE) so that color schemes
" render properly when inside 256-color tmux and GNU screen.
if &term =~ '256color'
  set t_ut=
endif

" -------------------------------------
"               Search
" -------------------------------------

set incsearch       " Search while typing
set hlsearch        " Highlight matching searches
set ignorecase      " ignore case while searching
set smartcase       " ignore case only when all lowercase

" Clear Search highlighting when hitting 'return'
" This unsets the 'last search pattern' register
nnoremap <CR> :noh<CR><CR>

" -------------------------------------
"             Indentation
" -------------------------------------

set autoindent      " Copy indentation from previous line
set expandtab       " Expands tabs into spaces
set tabstop=2       " Changes the width of the <TAB> character
set shiftwidth=2    " Affects how automatic indentation works (>>,<<,==)
set softtabstop=2   " Affects what happens when you press <TAB> or <BS>

" Enable file type detection
" Use the default filetype settings and
" Load indent files, to automatically do language-dependent indenting
filetype plugin indent on

" Show 'invisible' whitespace characters
set listchars=tab:▸-,trail:·,eol:¬,nbsp:_
"set list

" -------------------------------------
"               Folding
" -------------------------------------

set foldmethod=indent   " Fold based on indent level
set foldnestmax=3       " Deepest fold is 3 levels
set nofoldenable        " Don't fold by Default

" Space to toggle folds
nnoremap <Space> za
vnoremap <Space> za

" -------------------------------------
"             Status Line
" -------------------------------------

set laststatus=2                  " Always displays the status line
set statusline=%t\                " Tail of the filename
set statusline+=%y                " Filetype
set statusline+=%{FileFormat()}   " File Encoding/Format
set statusline+=%r                " Read only flag
set statusline+=%m                " Modified flag
set statusline+=%=                " left/right separator
set statusline+=%c%V,             " Cursor column
set statusline+=%l/%L             " Cursor line/total lines
set statusline+=\ %P              " Percent through file

" Returns a string '[Encoding,Format]' for the statusline
" if the encoding isn't 'utf-8' or the format isn't 'unix'
function! FileFormat()
  let l:fmt = ''
  if &fenc != 'utf-8'
    let l:fmt = strlen(&fenc) ? &fenc : 'none'
  endif

  if &ff != 'unix'
    let l:fmt = strlen(l:fmt) ? l:fmt . ',' . &ff : &ff
  endif

  return strlen(l:fmt) ? '[' . l:fmt . ']' : ''
endfunction

" -------------------------------------
"               Splits
" -------------------------------------

set splitbelow  " Open new splits to the bottom
set splitright  " Open new splits to the right

"nnoremap <silent> <Right> :call IntelligentVerticalResize('right')<CR>
"nnoremap <silent> <Left> :call IntelligentVerticalResize('left')<CR>
"" Only map up and down arrows to resize if the GUI is running
"" This is because the CLI interprets mouse scrolling as arrow events
"if has('gui_running')
"  nnoremap <silent> <Up> :resize +1<CR>
"  nnoremap <silent> <Down> :resize -1<CR>
"end

" Be aware of whether you are right or left vertical split
" so you can use arrow keys more naturally to rezie windows
function! g:IntelligentVerticalResize(direction) abort
  let l:window_resize_count = 5
  let l:current_window_is_last_window = (winnr() == winnr('$'))

  if (a:direction ==# 'left')
    let [l:modifier_1, l:modifier_2] = ['+', '-']
  else
    let [l:modifier_1, l:modifier_2] = ['-', '+']
  endif

  let l:modifier = l:current_window_is_last_window ? l:modifier_1 : l:modifier_2
  let l:command = 'vertical resize ' . l:modifier . l:window_resize_count . '<CR>'
  execute l:command
endfunction

" -------------------------------------
"             Gui Options
" -------------------------------------
if has('gui_running')
  set guioptions=agim
endif

" allows cursor change in tmux mode
"if exists('$TMUX')
"  let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
"  let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
"  let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
"else
"  let &t_SI = "\<Esc>]50;CursorShape=1\x7"
"  let &t_SR = "\<Esc>]50;CursorShape=2\x7"
"  let &t_EI = "\<Esc>]50;CursorShape=0\x7"
"endif

"set relativenumber!

" Key Remaps
noremap <c-s> :update<CR>
inoremap <c-s> <Esc>:update<CR>
vmap <c-s> <Esc>:update<CR>gv

" Execute current line or current selection as Vim EX commands.
nnoremap <F2> :exe getline(".")<CR>
vnoremap <F2> :<C-w>exe join(getline("'<","'>"),'<Bar>')<CR>

" Remove all trailing whitespace by pressing F5
nnoremap <F5> :let _s=@/<Bar>:%s/\s\+$//e<Bar>:let @/=_s<Bar><CR>

nnoremap <leader>m :call ToggleMouse()<CR>
function! ToggleMouse()
  " check if mouse is enabled
  if &mouse == 'a'
    " disable mouse
    set mouse=
  else
    " enable mouse everywhere
    set mouse=a
  endif
endfunc

nnoremap <leader>sp :set spell!<CR>

" edit vimrc and load vimrc bindings
nnoremap <leader>ev :vsp $MYVIMRC<CR>
nnoremap <leader>sv :source $MYVIMRC<CR>

" Convert word to all caps
" gUiwgi

" highlight last inserted text
nnoremap gV `[v`]

" set virtualedit+=block

" What is the current syntax highlighting group?
map <F3> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">" . " FG:" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"fg#") . " BG:" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"bg#")<CR>

" Highlights characters that exceed the 80 char/line maximum
highlight OverLength ctermbg=52 guibg=#592929
"match OverLength /\%>80v.\+/
" Show trailing whitespace
"autocmd BufNewFile,BufRead *.c,*.cc,*.cpp,*.h match OverLength /\s\+$/
" Show Tabs
"autocmd BufNewFile,BufRead *.c,*.cc,*.cpp,*.h match OverLength /\t/

" -------------------------------------
"         File Specific Settings
" -------------------------------------

autocmd BufNewFile,BufRead *.cc,*.cpp,*.h set syntax=cpp11
autocmd BufNewFile,BufRead *.md set syntax=markdown
autocmd BufNewFile,BufRead *.c,*.cc,*.cpp,*.h match OverLength /\%>80v.\+/

" Git Dev Settings
autocmd! BufNewFile,BufReadPost $HOME/work/git/* call SetupGitEnv()
function! SetupGitEnv()
  "let l:path = expand('%:p')
  setlocal tabstop=8 shiftwidth=8 softtabstop=8 noexpandtab
endfunction
